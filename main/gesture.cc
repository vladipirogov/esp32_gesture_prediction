#include <stdio.h>
#include <stdlib.h>
#include "esp_log.h"
#include "tensorflow/lite/micro/micro_mutable_op_resolver.h"
#include "tensorflow/lite/micro/micro_interpreter.h"
#include "tensorflow/lite/schema/schema_generated.h"
#include "tensorflow/lite/core/c/common.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/queue.h"

#include "mpu6050.h"
#include "model.h" //Generated by xxd
#include <esp_heap_caps.h>

#include "gesture.h"

#define TAG "GESTURE"
#define SAMPLE_SIZE 125  
#define FEATURES 4

// TensorFlow Lite
constexpr int kTensorArenaSize = 120 * 1024;
static uint8_t *tensor_arena;
const tflite::Model* model = nullptr;
tflite::MicroInterpreter* interpreter = nullptr;
TfLiteTensor* model_input = nullptr;
TfLiteTensor* output = nullptr;

mpu6050_acce_value_t acce;

/**
 *  TensorFlow Lite initialization function
 */
void tflite_init() {
    if (tensor_arena == NULL) {
        tensor_arena = (uint8_t *) heap_caps_malloc(kTensorArenaSize, MALLOC_CAP_INTERNAL | MALLOC_CAP_8BIT);
      }
      if (tensor_arena == NULL) {
        ESP_LOGE(TAG, "Couldn't allocate memory of %d bytes\n", kTensorArenaSize);
        return;
      }

    ESP_LOGI(TAG, "Model loading...");
    model = tflite::GetModel(gesture_model_tflite);
    if (model->version() != TFLITE_SCHEMA_VERSION) {
        ESP_LOGE(TAG, "Model version error! Expected %d, got %d", 
                 TFLITE_SCHEMA_VERSION, model->version());
        return;
    }

    static tflite::MicroMutableOpResolver<6> resolver;
    resolver.AddFullyConnected();
    resolver.AddRelu();
    resolver.AddSoftmax();

    static tflite::MicroInterpreter static_interpreter(model, resolver, tensor_arena, kTensorArenaSize);
    interpreter = &static_interpreter;

    if (interpreter->AllocateTensors() != kTfLiteOk) {
        ESP_LOGE(TAG, "Memory allocation error!");
        return;
    }

    model_input = interpreter->input(0);
    output = interpreter->output(0);

    ESP_LOGI(TAG, "TensorFlow Lite has been initialized.");
}

/**
 * Function to read data from MPU6050
 */
void collect_sensor_data(mpu6050_handle_t sensor, QueueHandle_t sensorQueue) {
    ESP_LOGI(TAG, "Data acquisition with MPU6050...");

    for (int i = 0; i < SAMPLE_SIZE; i++) {
        mpu6050_get_acce(sensor, &acce);

        model_input->data.f[i * 3] = acce.acce_x;
        model_input->data.f[i * 3 + 1] = acce.acce_y;
        model_input->data.f[i * 3 + 2] = acce.acce_z;

        vTaskDelay(pdMS_TO_TICKS(20));  // 50 Hz (20 ms)
    }


    // Launching the model
    if (interpreter->Invoke() != kTfLiteOk) {
        ESP_LOGE(TAG, "Model execution error!");
        return;
    }

    memcpy(&model_input->data.f[SAMPLE_SIZE * 3], output->data.f, FEATURES * sizeof(float));

    portBASE_TYPE xStatus = xQueueSend(sensorQueue, &model_input->data.f, 0);
    if( xStatus != pdPASS ) {
        ESP_LOGE(TAG, "Could not send sensor data to the queue.\r\n");
    }
}

/**
 * Main task
 */
extern "C" void gesture_predict(void *param) {
    MPUparams* mpu_params = (MPUparams *)param;
    mpu6050_handle_t sensor = mpu_params->sensor;
    QueueHandle_t sensorQueue = mpu_params->sensorQueue;

    tflite_init();
    while (1) {
        collect_sensor_data(sensor, sensorQueue);
    }
}
